"""
Your name: Alissa Graham
Your student number: A00785148

All of your code must go in this file.
"""
import random
import itertools
import time
import sys


def print_board(board: dict, rows: int, columns: int, character: dict) -> None:
    """
    Print a graphic map of the game.

    :param board: a dictionary
    :param rows: an integer
    :param columns: an integer
    :param character: a dictionary
    :pre-condition: board dictionary must be created by the make_board function
    :pre-condition: rows must be an integer strictly greater than zero
    :pre-condition: columns must be an integer strictly greater than zero
    :pre-condition: character dictionary must be created by the make_character function
    :post-condition: board will provide the room names to populate the room spaces on the map
    :post-condition: rows will provide the x-coordinates for each room
    :post-condition: columns will provide the y-coordinates for each room
    :post-condition: character will provide the location of the character to show on the game board
    :post-condition: character dictionary will not be changed
    :post-condition: prints a graphic representation of the game board.
    """
    room_initials = {"The Bridge": "[ ]", "Round Corridor": "[ ]", "straight Corridor": "[ ]",
                     "Main Engineering": "[ ]", "Transporter Room": "[ ]", "Auxiliary Control": "[ ]",
                     "Shuttle Bay": "[ ]", "Sick Bay": "[ ]", "Recreation Room": "[ ]",  "Briefing Room": "[ ]",
                     "Captain's Quarters": "[ ]", "First Officer's Quarters": "[ ]", "Doctor's Quarters": "[ ]",
                     "Crew Quarters": "[ ]", "Gym": "[ ]", "Arboretum": "[ ]", "Mess Hall": "[ ]",
                     "Cargo Bay": "[ ]", "Armory": "[ ]", "Jeffries Tube": "[ ]",
                     "Science Lab": "[ ]", "Astrometrics": "[ ]", "Airponics Bay": "[ ]",
                     "Deflector Control": "[ ]", "Navigational Control": "[ ]", "Environmental Control": "[ ]",
                     "Wall": "--", "Holodeck": "[!]", "character_position": "[*]"}

    for row in range(rows):
        for column in range(columns):
            room_name = board[(row, column)]
            if row == rows-5 and column == columns-4:
                print(room_initials['Holodeck'], end='')
            elif row == character['X-Coordinate'] and column == character['Y-Coordinate']:
                print(room_initials["character_position"], end='')
            elif room_name in board.values():
                print(room_initials[room_name], end='')
        print()


def random_room():
    """
    Generate a random room description from a list of room descriptions.

    This function is called by the make_board() function to populate the values for each coordinate key generated.

    :return: a random room description from a list of room descriptions.
    """
    room_values = ["The Bridge", "Round Corridor", "straight Corridor", "Main Engineering", "Transporter Room",
                   "Auxiliary Control", "Shuttle Bay", "Sick Bay", "Recreation Room",  "Briefing Room",
                   "Captain's Quarters", "First Officer's Quarters", "Doctor's Quarters", "Crew Quarters", "Gym",
                   "Arboretum", "Mess Hall", "Cargo Bay", "Armory", "Jeffries Tube", "Science Lab", "Astrometrics",
                   "Airponics Bay", "Deflector Control", "Navigational Control", "Environmental Control"]

    return room_values[random.randint(0, len(room_values)-1)]


def make_board(rows: int, columns: int) -> dict:
    """
    Create a playable game board dictionary with a specified number of rows and columns.

    :param rows: must be an integer
    :param columns: must be an integer
    :pre-condition: rows cannot be a negative integer
    :pre-condition: columns cannot be a negative integer
    :pre-condition: rows must be strictly greater than zero
    :pre-condition: columns must be strictly greater than zero
    :post-condition: generates a list of tuples combining the range_of_rows_list with range_of_columns_list
    :return: a list of tuples of the ranges of row and column numbers
    """
    board = {(row, column): random_room() for row in range(rows) for column in range(columns)}
    return board


def describe_current_location(board, character):
    """
    Return a string description for a location on the playable game board.

    :param board: a playable game board dictionary with a specified number of rows and columns
    :param character: a character dictionary with X-coordinate, Y-coordinate, and HP as keys
    :pre-condition: board must be previously generated by the make_board function
    :pre-condition: character must be previously generated by the make_character function
    :post-condition: board dictionary will not be changed
    :post-condition: character dictionary will not be changed
    :post-condition: the string description of the current location on the board that the character is in will be
    returned
    :return: a printed string description of the character's current location on the board

    >>> board_test = {(0, 0): "Empty Room", (0, 1): "Creepy Room", (1, 0): "Empty Room", (1, 1): "Creepy Room"}
    >>> character_test = {"X-Coordinate": 0, "Y-Coordinate": 0, "HP": 5}
    >>> describe_current_location(board_test, character_test)
    'Empty Room'

    >>> board_test = {(0, 0): "Empty Room", (0, 1): "Creepy Room", (1, 0): "Empty Room", (1, 1): "Creepy Room"}
    >>> character_test = {"X-Coordinate": 0, "Y-Coordinate": 1, "HP": 5}
    >>> describe_current_location(board_test, character_test)
    'Creepy Room'
    """
    current_character_location = (character["X-Coordinate"], character["Y-Coordinate"])
    description = board[current_character_location]
    return description


def name_character() -> dict:
    """
    Create a character dictionary with a user input name.

    :pre-condition: the dictionary will be created with a level 1 character title
    :post-condtion: the dictionary will have 'Name' key and the user input added to it
    :return: a character dictionary with a 'Name' key and the user input as its value
    """
    character = {'Title': 'Ensign'}
    print(f"\nGreetings, {character['Title']}!"
          f"\nGood to see you awake and reporting for duty on the USS Raman!"
          f"\nWe look forward to your help on our journeys!"
          f"\nWe're a science vessel, so we should have some quiet trips. Hope it won't be too boring for you."
          f"\nBy the way, what's your name?")
    character['Name'] = input()

    return character


def character_class_statistics() -> dict:
    """
    Provide the base character stats for each class that the user can choose.

    This function is invoked in other functions which require access to the information about the base classes, such as
    class_info() and choose_class().

    :return: dictionary containing the stats of the four class options the user can choose from
    """
    character_statistics = {'1': {'Division': 'Medical', 'HP': 100, 'Melee Attack': 30, 'Long-Range Attack': 35,
                                  'Melee Weapon': 'KaBar Combat Knife', 'Long-Range Weapon': 'type 1 phaser'},
                            '2': {'Division': 'Engineering', 'HP': 75, 'Melee Attack': 30, 'Long-Range Attack': 35,
                                  'Melee Weapon': 'KaBar Combat Knife', 'Long-Range Weapon': 'type 3 phaser rifle'},
                            '3': {'Division': 'Command', 'HP': 75, 'Melee Attack': 40, 'Long-Range Attack': 35,
                                  'Melee Weapon': 'KaBar Combat Knife', 'Long-Range Weapon': 'type 2 phaser pistol'},
                            '4': {'Division': 'Security', 'HP': 100, 'Melee Attack': 50, 'Long-Range Attack': 25,
                                  'Melee Weapon': 'Katana', 'Long-Range Weapon': 'fists'}}

    return character_statistics


def get_user_choice_for_information(character: dict) -> None:
    """
    Get the user input to display class information for each character class.

    :param character: a dictionary
    :pre-condition: character dictionary must be created by the name_character function
    :post-condition: character dictionary will populate the formatted strings with the Name value
    :post-condition: character dictionary will not be changed
    :post-condition: will call another function to return information based on the option choice provided
    """
    option_choice = ''
    while option_choice != 's':
        option_choice = input(f"\nSince you're new here, {character['Title']} {character['Name']}."
                              f"\nLet's give you an overview of what departments you can work in!"
                              f"\nLet's get started."
                              f"\nThere are 4 divisions on this ship for you to choose from:"
                              f"\nPlease type the number associated with your choice to learn more."
                              f"\n[1] \tMedical"
                              f"\n[2] \tEngineering"
                              f"\n[3] \tCommand"
                              f"\n[4] \tSecurity."
                              f"\nType 's' if you already know all of this and want to skip.")

        if option_choice not in map(str, range(1, 5)) and option_choice != 's':
            option_choice = input("\nError! Bad entry. Please try again. Please enter: 1, 2, 3, or 4."
                                  "\nIf you would like to skip this, please press 's'.")
        elif option_choice in map(str, range(1, 5)):
            class_information(character, option_choice)
            time.sleep(10.00)
        elif option_choice == 's':
            print(f"\nLooks like you know all this already, {character['Title']} {character['Name']}! Awesome!\n")


def class_information(character: dict, class_number: str) -> None:
    """
    Print the information for each character class.

    This function is called by the get_user_choice_for_information function to return the character class description
    and statistics called by user input.

    :param character: a dictionary
    :param class_number: a string
    :pre-condition: character dictionary must be created by the name_character function
    :pre-condition: class_number is an integer input as a string between the range of 1 and 4 inclusive
    :post-condition: character dictionary will not be changed
    :post-condition: prints character class information
    """
    character_stats = character_class_statistics()

    character_descriptions = {'1': "\nYou'll start off as a medical assistant which means that you will be assisting "
                                   "\nthe Chief Medical Officer. Because you are a health practitioner, "
                                   "\nyou are able to provide a bit better healing for yourself if there is any ruckus."
                                   "\nBut don't worry, we're a quiet ship. Anyways, you can heal yourself a"
                                   "\nlittle bit faster and your health starts out a little bit higher, but because"
                                   "\nyou're not a fighter you don't have a lot of weaponry at your disposal.",
                              '2': "\nYou're job is to maintain the ship's functionality. This can include "
                                   "\nmaintaining/improving the warp drive and maintaining the ship's database, "
                                   "\ncircuitry, and processors. As well as, working on holographic emitters,"
                                   "\ntractor beams, transporter components, and observational equipment. As a "
                                   "\nresult of being so technically savvy, your phasers (long-range attack) does "
                                   "\nmore damage then they traditionally would because you've got the smarts to"
                                   "\nupgrade it's technology!",
                              '3': "\nPlanning on rising up the ranks to the Captain's chair? Command officers are "
                                   "\nthe most well rounded of all of the divisions. Because you need to understand"
                                   "\nhow your ship works in order to lead, you get a balance of everything during"
                                   "\nyour training.",
                              '4': "\nPart of the ship's security department, you have a vast knowledge of security "
                                   "\nprotocols. Your duties will typically include the protection of Starfleet or "
                                   "\nFederation assets, preventing and investigating crimes, and personal protection"
                                   "\nof Starfleet officers and Federation foreign dignitaries. Because of your rigid "
                                   "\ntraining and specialities, your hand-to-hand combat skills and health are above"
                                   "\naverage by comparison to other departments."}

    if class_number == '1':
        print(f"\nSo, you want to know about {character_stats['1']['Division']}, {character['Title']}"
              f" {character['Name']}?"
              f"\n{character_descriptions['1']}"
              f"\n\nYour stats will be as follows:"
              f"\nHealth: {character_stats['1']['HP']}"
              f"\nMelee Attack: {character_stats['1']['Melee Attack']}"
              f"\nLong-Range Attack: {character_stats['1']['Long-Range Attack']}")

    elif class_number == '2':
        print(f"\nSo, you want to know about {character_stats['2']['Division']}, {character['Title']}"
              f" {character['Name']}?"
              f"\n{character_descriptions['2']}"
              f"\n\nYour stats will be as follows:"
              f"\nHealth: {character_stats['2']['HP']}"
              f"\nMelee Attack: {character_stats['2']['Melee Attack']}"
              f"\nLong-Range Attack: {character_stats['2']['Long-Range Attack']}")

    elif class_number == '3':
        print(f"\nSo, you want to know about {character_stats['3']['Division']}, {character['Title']}"
              f" {character['Name']}?"
              f"\n{character_descriptions['3']}"
              f"\n\nYour stats will be as follows:"
              f"\nHealth: {character_stats['3']['HP']}"
              f"\nMelee Attack: {character_stats['3']['Melee Attack']}"
              f"\nLong-Range Attack: {character_stats['3']['Long-Range Attack']}")

    elif class_number == '4':
        print(f"\nSo, you want to know about {character_stats['4']['Division']}, {character['Title']}"
              f" {character['Name']}?"
              f"\n{character_descriptions['4']}"
              f"\n\nYour stats will be as follows:"
              f"\nHealth: {character_stats['4']['HP']}"
              f"\nMelee Attack: {character_stats['4']['Melee Attack']}"
              f"\nLong-Range Attack: {character_stats['4']['Long-Range Attack']}")


def introduction(character: dict) -> None:
    """
    Print story information to the user.

    This function is called in the beginning of the game loop as an enrichment of the game story for the user.

    :param character: a dictionary
    :pre-condition: the character dictionary must be created by the make_character function
    :post-condition: the character dictionary will not be changed
    :post-condition: print text for the user
    """
    print(f"\nWe can't tell you how much we are happy to have new recruits to help us on our mission, "
          f"{character['Title']}!"
          f"\nTypically we are just deployed to explore and research collapsing stars... "
          f"\nSo, you can imagine that we don't get recruits scrambling to join us."
          f"\nWe're not as EXCITING as the Enterprise or Voyager...\n\n")
    time.sleep(5)
    print(r"""                                    
 ____   ___   ___  __   __ _ 
|  _ \ / _ \ / _ \|  \ /  | |
| |_) ) | | | | | |   v   | |
|  _ (| | | | | | | |\_/| |_|
| |_) ) |_| | |_| | |   | |_ 
|____/ \___/ \___/|_|   |_(_)        
          """)
    time.sleep(1)
    print(f"\n\n...What was that!?"
          f"\n\nIs that a Red Alert?!"
          f"\nI think we've just been boarded! By who, I don't know!"
          f"\nI know you just got here, but I need you to take a look around the ship and see what you can find."
          f"\nBe careful, {character['Title']}. It could be dangerous.\n\n")
    time.sleep(8)


def choose_class() -> dict:
    """
    Determine which division stats the user will have based on user input.

    :return: the character statistics dictionary associated with the user's input choice
    """
    character_statistics = character_class_statistics()
    divisions = ['Medical', 'Engineering', 'Command', 'Security']
    for number, division in enumerate(divisions, start=1):
        print(f"[{number}] \t{division}")
    user_choice = input("\nWhat division would you like to be in?")
    while user_choice not in map(str, range(1, 5)):
        user_choice = input("\nThat's not a division! Please choose from 1, 2, 3, or 4")

    if user_choice in map(str, range(1, 5)):
        print(f"\nWelcome to {character_statistics[user_choice]['Division']}! Happy to have you!")
        return character_statistics[user_choice]


def make_character(character: dict, character_class: dict) -> dict:
    """
    Assemble a character dictionary containing the character's name and statistics based on their division.

    :param character:  character is a dictionary
    :param character_class:  character_class is a dictionary
    :pre-condition: character must be a dictionary created by the name_character function
    :pre-condition: character_class must be a dictionary created by the choose_division function
    :post-condition: character will be populated with the required stats from the character_class dictionary
    :post-condition: character_class dictionary will not be changed
    :return: character dictionary with additional stats provided by character_class dictionary
    """
    character['Division'] = character_class['Division']
    character['Max HP'] = character_class['HP']
    character['HP'] = character_class['HP']
    character['Melee Attack'] = character_class['Melee Attack']
    character['Long-Range Attack'] = character_class['Long-Range Attack']
    character['Melee Weapon'] = character_class['Melee Weapon']
    character['Long-Range Weapon'] = character_class['Long-Range Weapon']
    character['Level'] = 1
    character['EXP'] = 0
    character['X-Coordinate'] = 0
    character['Y-Coordinate'] = 0

    return character


def get_user_move(character) -> str:
    """
    Accept a user input within a specific range and return it has a direction.

    :pre-condition: user choice must be within the range of 1 and 4 inclusive
    :pre-condition: choice must not be a letter or word
    :post-condition: character dictionary will not be changed
    :post-condition: user choice will be saved to direction variable and returned
    :return: user input string saved to direction variable
    """
    directions = ['North', 'East', 'South', 'West']
    for number, direction in enumerate(directions, start=1):
        print(f"[{number}] \t{direction}")

    direction_choice = input("\nPlease input your direction choice or [Q] to Quit"
                             "\n Note: [*] is your current location on the map.\n").title()
    while direction_choice not in map(str, range(1, 5)) and direction_choice != 'Q':
        direction_choice = input("\nThat, sir, is not an option. Please enter your desired "
                                 "\ndirection (1, 2, 3, 4, or Q only): ").title()
    if direction_choice in map(str, range(1, 5)):
        return direction_choice
    elif direction_choice == 'Q':
        end_game(character)


def validate_move(board: dict, character: dict, direction: str) -> bool:
    """
    Check to see if the character move is within the board dictionary keys.

    :param board: a playable game board dictionary with a specified number of rows and columns as tuple keys
    :param character: a character dictionary with X-coordinate, Y-coordinate, and HP as string keys
    :param direction: an integer within the range of 1 and 4 (upper bound inclusive)
    :pre-condition: board must be previously generated by the make_board function
    :pre-condition: character must be previously generated by the make_character function
    :pre-condition: direction must be previously input through the get_user_choice function
    :post-condition: character dictionary will not be changed
    :post-condition: board dictionary will not be changed
    :post-condition: will determine whether move is valid and if so returns True
    :return: True if move is valid, else False
    """
    if direction == '1':
        test_position = (character["X-Coordinate"] - 1, character["Y-Coordinate"])
        return True if test_position in board.keys() else False
    elif direction == '2':
        test_position = (character["X-Coordinate"], character["Y-Coordinate"] + 1)
        return True if test_position in board.keys() else False
    elif direction == '3':
        test_position = (character["X-Coordinate"] + 1, character["Y-Coordinate"])
        return True if test_position in board.keys() else False
    else:
        test_position = (character["X-Coordinate"], character["Y-Coordinate"] - 1)
        return True if test_position in board.keys() else False


def move_character(character: dict, direction: str) -> dict:
    """
    Update the character's coordinates in the desired direction.

    :param character: a dictionary
    :param direction: a string
    :pre-condition: character must be previously generated by the make_character function
    :pre-condition: direction must be previously input through the get_user_choice function
    :post-condition: character dictionary HP value will not be changed
    :post-condition: character dictionary "X-Coordinate" or "Y-Coordinate" value will be changed
    :return: updated character "X-Coordinate" or "Y-Coordinate"

    >>> direction_test = '1'
    >>> character_test = {"X-Coordinate": 0, "Y-Coordinate": 2, "HP": 5}
    >>> move_character(character_test, direction_test)
    {'X-Coordinate': -1, 'Y-Coordinate': 2, 'HP': 5}

    >>> direction_test = '2'
    >>> character_test = {"X-Coordinate": 0, "Y-Coordinate": 2, "HP": 5}
    >>> move_character(character_test, direction_test)
    {'X-Coordinate': 0, 'Y-Coordinate': 3, 'HP': 5}
    """
    if direction == '1':
        character["X-Coordinate"] -= 1
        return character
    elif direction == '2':
        character["Y-Coordinate"] += 1
        return character
    elif direction == '3':
        character["X-Coordinate"] += 1
        return character
    else:
        character["Y-Coordinate"] -= 1
        return character


def hp_regeneration(character: dict) -> dict:
    """
    Add to the character dictionary 'HP' value if it is less than the 'HP Max' value.

    :param character: a character dictionary
    :pre-condition: character must be previously generated by the make_character function
    :post-condition: character value for 'HP' key will be increased
    :return: Updated character dictionary

    >>> character_test = {"Division": "Medical", "X-Coordinate": 1, "Y-Coordinate": 1, "HP": 5, "Max HP": 10}
    >>> hp_regeneration(character_test)
    {'Division': 'Medical', 'X-Coordinate': 1, 'Y-Coordinate': 1, 'HP': 10, 'Max HP': 10}

    >>> character_test = {"Division": "Engineering", "X-Coordinate": 1, "Y-Coordinate": 1, "HP": 5, "Max HP": 10}
    >>> hp_regeneration(character_test)
    {'Division': 'Engineering', 'X-Coordinate': 1, 'Y-Coordinate': 1, 'HP': 7, 'Max HP': 10}
    """
    if character['Division'] == 'Medical' and character['HP'] < character['Max HP']:
        character['HP'] += 5
        return character
    elif character['Division'] != 'Medical' and character['HP'] < character['Max HP']:
        character['HP'] += 2
        return character
    return character


def check_for_enemy() -> bool:
    """
    Generate a random number within a range and determines True or False depending on that number.

    :return: True if the random number is within the specified range, else False.
    """
    return True if random.randrange(0, 100) <= 19 else False


def enemy_to_fight() -> dict:
    """
    Generate a random number in a given range and returns the dictionary associated with that number key.

    :return: a dictionary with enemy information
    """
    enemies = {1: {'Name': 'Romulan', 'HP': 100, 'Attack': 35, 'EXP Earned': 75, 'Weapon': "Teral'n",
                   'Move': 'swings'},
               2: {'Name': 'Borg', 'HP': 150, 'Attack': 35, 'EXP Earned': 90, 'Weapon': 'hands, to assimilate you!',
                   'Move': 'grabs'},
               3: {'Name': 'Klingon', 'HP': 200, 'Attack': 50, 'EXP Earned': 100, 'Weapon': "Bat'leth",
                   'Move': 'swipes'},
               4: {'Name': 'Control Minion', 'HP': 125, 'Attack': 35, 'EXP Earned': 75, 'Weapon': 'nanobots',
                   'Move': 'shoots'},
               5: {'Name': 'Species 8472', 'HP': 100, 'Attack': 55, 'EXP Earned': 100, 'Weapon': 'claws',
                   'Move': 'swipes'},
               6: {'Name': "Jem'Hadar", 'HP': 150, 'Attack': 40, 'EXP Earned': 80, 'Weapon': "Kar'takin",
                   'Move': 'stabs'}
               }

    return enemies[random.randint(1, 6)]


def fight_or_flee(character: dict, enemy: dict) -> bool:
    """
    Determine whether damage is done to the user character if they choose to flee from the enemy.

    This function is called within the time_to_fight function during the combat loop.

    :param character: a dictionary
    :param enemy: a dictionary returned by enemy_to_fight
    :pre-condition: character must be previously generated by the make_character function
    :pre-condition: enemy must be stored in the enemy variable within time_to_fight
    :post-condition: character dictionary will be updated flee is 'y' and random number within defined range.
    :return: True if user chooses to flee, else False
    """
    flee_choice = ['f', 'r']
    flee = ''
    while flee.lower() not in flee_choice:
        print(f"\n{character['Title']} {character['Name']}! The enemy looks strong!"
              f"\nDo you want to stay and fight [f] or will you flee [r]?"
              f"\nStarfleet won't judge you!")
        flee = input()

    if flee.lower() == flee_choice[1]:
        if random.randrange(0, 100) <= 19:
            character['HP'] -= enemy['Attack']/2
            print(f"\nYou tripped as you ran and the {enemy['Name']} smacks you, doing {enemy['Attack']/2} damage!")
            return True
        elif flee.lower():
            print(f"\n{character['Name']}, looks like you just barely got away!")
            return True
    return False


def time_to_fight(character: dict, enemy: dict) -> dict:
    """
    Drive the fight sequence between the character and a randomly generated enemy.

    :param character: a dictionary
    :param enemy: a dictionary
    :pre-condition: character dictionary must be previously generated by the make_character function
    :pre-condition: enemy dictionary must be provided by the enemy_to_fight function
    :post-condition: character dictionary may be updated depending on the outcome
    :return: the updated character dictionary
    """
    print(f"\nOH NO! You've run into a {enemy['Name']}\n")
    while check_dead(enemy) is False and check_dead(character) is False:
        if fight_or_flee(character, enemy) is False:
            print(f"\nYour health: {character['HP']}"
                  f"\nEnemy health: {enemy['HP']}\n"
                  + ''.join(itertools.repeat('-', 40)))
            check_fight_move(character, enemy)
            if enemy_flees(character, enemy):
                check_experience(character)
                break
        else:
            print(f"\nYour health: {character['HP']}"
                  f"\nEnemy health: {enemy['HP']}\n"
                  + ''.join(itertools.repeat('-', 40)))
            return character

    if check_dead(enemy) is True:
        character['EXP'] += enemy['EXP Earned']
        print(f"\nYou have earned {enemy['EXP Earned']} EXP!"
              f"\nYou now have {character['EXP']} total EXP. ")
        check_experience(character)
    elif check_dead(character) is True:
        character_death(character)


def enemy_flees(character: dict, enemy: dict) -> bool:
    """
    Determine if the enemy flees.

    This function is called by the time_to_fight() function after every fight round to determine if the enemy will flee.

    :param character: a dictionary
    :param enemy: a dictionary
    :pre-condition: the character dictionary must have been created by the make_character function
    :pre-condition: the enemy dictionary must be from the enemy_to_fight function
    :post-condition: the character dictionary will not be changed
    :post-condition: the enemy dictionary will not be changed
    :post-condition: returns true if a random number less or equal to 19 is generated, including 0
    :return: a boolean, True or False
    """
    if random.randrange(0, 100) <= 19:
        print(f"\nLooks like you really scared them, {character['Title']}. They ran away."
              f"\nWe're going to have to find them somewhere on the ship though!\n")
        character['EXP'] += enemy['EXP Earned'] / 2
        print(f"\nYou have earned {enemy['EXP Earned']/2} EXP!"
              f"\nYou now have {character['EXP']} total EXP.\n")
        return True
    else:
        return False


def check_fight_move(character: dict, enemy: dict) -> None:
    """
    Call a function depending on the user's choice of attack.

    This function is called from the time_to_fight() function if the user does not previously decide to flee. This
    function utilizes information from time_to_fight for its parameters.

    :param character: a dictionary
    :param enemy: a dictionary returned by enemy_to_fight
    :pre-condition: character dictionary must be previously generated by the make_character function
    :pre-condition:  enemy must be called and stored in the enemy variable within time_to_fight
    :post-condition: melee_fight or long_range_fight functions will be called depending on user input
    """
    fight_move = input("\nTIME TO FIGHT!"
                       "\nHow are you going to attack?"
                       "\n[m] \t Melee Attack"
                       "\n[l] \t Long-Range Attack")
    moves = ['m', 'l']
    while fight_move not in moves:
        print(f"\nThe {enemy['Name']} won't wait forever!"
              "\nHow are you going to attack!?"
              "\n[m] \t Melee Attack"
              "\n[l] \t Long-Range Attack")
        fight_move = input()

    if fight_move == moves[0]:
        melee_fight(character, enemy)
    elif fight_move == moves[1]:
        long_range_fight(character, enemy)


def melee_fight(character: dict, enemy: dict) -> dict:
    """
    Determine whether the character or enemy does damage if the melee attack is chosen.

    This function is called by the check_fight_move function when the user chooses which attack they would like to use.

    :param character: a dictionary
    :param enemy: a dictionary returned by enemy_to_fight
    :pre-condition: character dictionary must be previously generated by the make_character function
    :pre-condition: enemy must be called and stored in the enemy variable within time_to_fight
    :post-condition: character dictionary 'HP' value may be updated
    :post-condition: enemy dictionary 'HP' value may be updated
    :return: the updated character or enemy dictionary
    """
    if random.randrange(0, 100) <= 74:
        enemy['HP'] -= character['Melee Attack']
        print(f"\nNice. You swung your {character['Melee Weapon']} at the {enemy['Name']} and did"
              f" {character['Melee Attack']} damage.")
        return enemy
    else:
        print(f"\nOOF. You swung wide and missed!")
        if random.randrange(0, 100) <= 49:
            character['HP'] -= enemy['Attack']
            print(f"\nYour opponent {enemy['Move']} at you with their {enemy['Weapon']}! It did a "
                  f"\nwhopping {enemy['Attack']} damage!")
        return character


def long_range_fight(character: dict, enemy: dict) -> dict:
    """
    Determine whether the character or enemy does damage if the melee attack is chosen.

    This function is called by the check_fight_move function when the user chooses which attack they would like to use.

    :param character: a dictionary
    :param enemy: a dictionary returned by enemy_to_fight
    :pre-condition: character dictionary must be previously generated by the make_character function
    :pre-condition: enemy must be called and stored in the enemy variable within time_to_fight
    :post-condition: character dictionary 'HP' value may be updated
    :post-condition: enemy dictionary 'HP' value may be updated
    :return: the updated character or enemy dictionary
    """
    check_for_attack = random.randrange(0, 100)
    if check_for_attack <= 89:
        enemy['HP'] -= character['Long-Range Attack']
        print(f"\nWOW! Your {character['Long-Range Weapon']} just blasted the enemy for "
              f"{character['Long-Range Attack']} damage!")
        return enemy
    else:
        print(f"\nEek! You just made a nice mark in the wall, {character['Title']} {character['Name']}!")
        if random.randrange(0, 100) <= 49:
            character['HP'] -= enemy['Attack']
            print(f"\nYou're going to feel that {enemy['Weapon']} hit for {enemy['Attack']} damage in the morning.")
        return character


def is_boss(character: dict, rows: int, columns: int) -> bool:
    """
    Check to see if where the character moved to is the fixed location of the game boss.

    :param character: a character dictionary
    :param rows: an integer
    :param columns: an integer
    :pre-condition: character must be previously generated by the make_character function
    :pre-condition: an integer strictly greater than 0
    :pre-condition: an integer strictly greater than 0
    :post-condition: character dictionary will not change
    :return:
    """
    boss = {'Name': 'TRIBBLE!', 'HP': 500, 'Attack': 5, 'Weapon': 'Fuzzy', 'Move': 'smothers'}
    character_coordinates = (character['X-Coordinate'], character['Y-Coordinate'])
    if character_coordinates == (rows - 5, columns - 4):
        print(f"\n{character['Title']} {character['Name']}!!!"
              "\nWhat's that cute little fluffy thing over there?")
        boss_battle(character, boss)
    else:
        return False


def boss_battle(character: dict, boss: dict) -> None:
    """
    Drive the battle between the user and the boss.

    This function is invoked in the is_boss function. It will be called if the user reaches the location on the map
    where the boss is located.

    :param character: a dictionary
    :param boss: a dictionary
    :pre-condition: character must be previously generated by the make_character function
    :pre-condition: boss dictionary must be passed from the is_boss function
    :post-condition: will call the beat_boss or character_death function when the boss or the character 'HP' value is 0
    """
    move_count = 0
    print(f"OH NO! You've run into a {boss['Name']}")
    while check_dead(boss) is False and check_dead(character) is False:
        print(f"\nYour health: {character['HP']}"
              f"\nBoss health: {boss['HP']}\n"
              + ''.join(itertools.repeat('-', 40)))
        check_fight_move(character, boss)
        move_count += 1
        if move_count % 3 == 0:
            boss['HP'] *= 2
            boss['Attack'] *= 2
            print(f"\n\nOH NO! The {boss['Name']}... It multiplied!")
            if move_count > 6:
                boss['HP'] = 1
                print(f"\nLooks like you have an opening, {character['Title']} {character['Name']}!"
                      f"\nGet 'em!!")

    if check_dead(boss) is True:
        print(f"\nYou killed the {boss['Name']}!"
              f"\nYou win all the fame and glory, {character['Title']} {character['Name']}")
        end_game(character)
    else:
        print(f"\nI'm sorry, {character['Title']} {character['Name']}"
              f"\nYou died.. all though I don't know how you managed that..."
              f"\nWe will miss you and give you a proper space funeral.")
        end_game(character)


def check_dead(character: dict) -> bool:
    """
    Check the character 'HP' to determine if the character is dead.

    :param character: a character dictionary
    :pre-condition: character must be previously generated by the make_character function
    :post-condition: character dictionary will not be changed
    :return: True is character 'HP' is 0, False if it is not.

    >>> character_test = {'Name': 'Testy McTesterson', 'Division': 'Medical', 'HP': 0}
    >>> check_dead(character_test)
    True

    >>> character_test = {'Name': 'Testy McTesterson', 'Division': 'Medical', 'HP': 100}
    >>> check_dead(character_test)
    False
    """
    return True if character['HP'] <= 0 else False


def check_experience(character):
    """
    Check if the total experience of the character is at or above the threshold required for the next level.

    This function is only invoked in the time_to_fight function when the enemy is beaten.

    :param character: a character dictionary
    :pre-condition: character dictionary must be previously created by the make_character function
    :post-condition: character dictionary will be updated with the new statistics if the level requirements are met
    :post-condition: character dictionary will be unchanged if the level requirements are not met
    :return: the character dictionary
    """
    if character['EXP'] >= 200 and character['Level'] == 1:
        character['Level'] += 1
        level_up(character)
        print(f"\nCongratulations {character['Name']}!"
              f"\nYour new stats are as follows:"
              f"\n\nHealth: {character['HP']}"
              f"\nMelee Attack: {character['Melee Attack']}"
              f"\nLong-Range Attack: {character['Long-Range Attack']}")
        return character
    elif character['EXP'] >= 450 and character['Level'] == 2:
        character['Level'] += 1
        level_up(character)
        print(f"\nCongratulations {character['Name']}!"
              f"\nYour new stats are as follows:"
              f"\n\nHealth: {character['HP']}"
              f"\nMelee Attack: {character['Melee Attack']}"
              f"\nLong-Range Attack: {character['Long-Range Attack']}")
        return character
    else:
        return character


def level_up(character):
    """
    Update the character dictionary with the new character statistics as required by the new character level.

    This function is called if the character dictionary meets certain conditions outlined in the check_experience()
    function.

    :param character: a character dictionary
    :pre-condition: character dictionary must be previously created by the make_character function
    :post-condition: the character dictionary will be updated with the new character statistics
    :return: an updated character dictionary
    """
    levels = {2: {'Title': 'Lieutenant Junior Grade',
                  'Medical': {'HP': 150, 'Melee Attack': 40, 'Long-Range Attack': 45},
                  'Engineering': {'HP': 125, 'Melee Attack': 35, 'Long-Range Attack': 50},
                  'Command': {'HP': 135, 'Melee Attack': 50, 'Long-Range Attack': 45},
                  'Security': {'HP': 200, 'Melee Attack': 100, 'Long-Range Attack': 50}},
              3: {'Title': 'Lieutenant',
                  'Medical': {'HP': 300, 'Melee Attack': 50, 'Long-Range Attack': 55},
                  'Engineering': {'HP': 200, 'Melee Attack': 45, 'Long-Range Attack': 65},
                  'Command': {'HP': 250, 'Melee Attack': 65, 'Long-Range Attack': 60},
                  'Security': {'HP': 400, 'Melee Attack': 175, 'Long-Range Attack': 75}}}
    character['Title'] = levels[character['Level']]['Title']
    character['HP'] = levels[character['Level']][character['Division']]['HP']
    character['Max HP'] = levels[character['Level']][character['Division']]['HP']
    character['Melee Attack'] = levels[character['Level']][character['Division']]['Melee Attack']
    character['Long-Range Attack'] = levels[character['Level']][character['Division']]['Long-Range Attack']
    return character


def end_game(character: dict) -> None:
    """
    End the game.

    This function is called if the user determines they would like to quit the game and enters that command where it is
    available.

    :param character: a character dictionary
    :pre-condition: the character dictionary must have been generated by the make_character function
    :post-condition: character dictionary will not be changed
    :post-condition: Exit the game.
    """
    print(f"\nThanks for playing, {character['Title']} {character['Name']}!"
          f"\nLive long and Prosper."
          r"""
                                                       .
                                                      .:.
                                                     .:::.
                                                    .:::::.
                                                ***.:::::::.***
                                           *******.:::::::::.*******       
                                         ********.:::::::::::.********     
                                        ********.:::::::::::::.********    
                                        *******.::::::'***`::::.*******    
                                        ******.::::'*********`::.******    
                                         ****.:::'*************`:.****
                                           *.::'*****************`.*
                                           .:'  ***************    .
                                          .
          """
          )
    sys.exit(0)


def character_death(character):
    """
    End the game.

    This function is called if the user's character hp becomes less or equal to zero. It is invoked through the
    time_to_fight() and boss_battle() functions.

    :param character: a character dictionary
    :pre-condition: the character dictionary must have been generated by the make_character function
    :post-condition: character dictionary will not be changed
    :post-condition: Exit the game
    """
    print("\nSo you will understand when I say, "
          "\n'Death is that state in which one exists only in the memory of others..."
          "\nwhich is why it is not an end.' "
          "\nNo goodbyes. Just good memories. Hailing frequencies closed, sir."
          "\n"
          f"\nFarewell, {character['Title']} {character['Name']}, we hardly knew ye.")
    sys.exit(0)


def beat_boss(character):
    """
    End the game.

    This function is called if the boss is beaten. It is invoked through the boss_battle() functions.

    :param character: a character dictionary
    :pre-condition: the character dictionary must have been generated by the make_character function
    :post-condition: character dictionary will not be changed
    :post-condition: Exit the game
    """
    print("\nHeghluâ€™meH QaQ jajvam!"
          f"\nToday is a good day to die, isn't it {character['Title']} {character['Name']}?"
          r"""
          .         _  .          .          .    +     .          .          .      .
        .(_)          .            .            .            .       :
        .   .      .    .     .     .    .      .   .      . .  .  -+-        .
          .           .   .        .           .          /         :  .
    . .        .  .      /.   .      .    .     .     .  / .      . ' .
        .  +       .    /     .          .          .   /      .
       .            .  /         .            .        *   .         .     .
      .   .      .    *     .     .    .      .   .       .  .
          .           .           .           .           .         +  .
  . .        .  .       .   .      .    .     .     .    .      .   .

 .   +      .          ___/\_._/~~\_...__/\__.._._/~\        .         .   .
       .          _.--'                              `--./\          .   .
           /~~\/~\                                         `-/~\_            .
 .      .-'                                                      `-/\_
  _/\.-'                                                          __/~\/\-.__
.'                                                                           `.dp
          """
          "\nYOU WIN!")
    sys.exit(0)


def game():
    """
    Drive the main game loop.
    """
    rows = 25
    columns = 25
    board = make_board(rows, columns)
    name = name_character()
    time.sleep(1.00)
    print(r"""
 _      _____ _     ____  ____  _      _____   _____  ____    
/ \  /|/  __// \   /   _\/  _ \/ \__/|/  __/  /__ __\/  _ \  
| |  |||  \  | |   |  /  | / \|| |\/|||  \      / \  | / \|    
| |/\|||  /_ | |_/\|  \_ | \_/|| |  |||  /_     | |  | \_/|    
\_/  \|\____\\____/\____/\____/\_/  \|\____\    \_/  \____/                                                                                                                                          
 _____  ____  _____ _  __   _____  _     _____   ____  _____  ____  ____  ____ 
/__ __\/  __\/  __// |/ /  /__ __\/ \ /|/  __/  / ___\/__ __\/  _ \/  __\/ ___\
  / \  |  \/||  \  |   /     / \  | |_|||  \    |    \  / \  | / \||  \/||    \
  | |  |    /|  /_ |   \     | |  | | |||  /_   \___ |  | |  | |-|||    /\___ |
  \_/  \_/\_\\____\\_|\_\    \_/  \_/ \|\____\  \____/  \_/  \_/ \|\_/\_\\____/
            """)
    time.sleep(1.00)
    get_user_choice_for_information(name)
    character_class = choose_class()
    character = make_character(name, character_class)
    introduction(character)
    print_board(board, rows, columns, character)
    while check_dead(character) is False:
        direction = get_user_move(character)
        valid_move = validate_move(board, character, direction)
        if valid_move:
            move_character(character, direction)
            print("\nYou enter " + describe_current_location(board, character) + "\n")
            hp_regeneration(character)
            print_board(board, rows, columns, character)
            is_boss(character, rows, columns)
            if is_boss(character, rows, columns) is not True:
                there_is_a_challenger = check_for_enemy()
                if there_is_a_challenger:
                    enemy = enemy_to_fight()
                    time_to_fight(character, enemy)
        else:
            print(f"Ouch, why would you walk into the ship's wall, {character['Title']} {character['Name']}?")


def main():
    """
    Drive the program.
    """
    game()


if __name__ == "__main__":
    main()
